//@version=5
//
strategy(title='God 62 PERSONAL - ADVANCED ALGORITHM', overlay=true, pyramiding=0, default_qty_type=strategy.percent_of_equity, default_qty_value=10, calc_on_every_tick=false)
//
// === INPUTS ===
res    = input.timeframe(title='TIMEFRAME', defval='15', group ="NON REPAINT")
useRes = input(defval=true, title='Use Alternate Signals')
intRes = input.int(defval=8, title='Multiplier for Alternate Signals')
stratRes = timeframe.ismonthly ? str.tostring(timeframe.multiplier * intRes, '###M') : timeframe.isweekly ? str.tostring(timeframe.multiplier * intRes, '###W') : timeframe.isdaily ? str.tostring(timeframe.multiplier * intRes, '###D') : timeframe.isintraday ? str.tostring(timeframe.multiplier * intRes, '####') : '60'
basisType = input.string(defval='ALMA', title='MA Type: ', options=['TEMA', 'HullMA', 'ALMA'])
basisLen = input.int(defval=2, title='MA Period', minval=1)
offsetSigma = input.int(defval=5, title='Offset for LSMA / Sigma for ALMA', minval=0)
offsetALMA = input.float(defval=0.85, title='Offset for ALMA', minval=0, step=0.01)
scolor = input(true, title='Show coloured Bars to indicate Trend?')
delayOffset = input.int(defval=0, title='Delay Open/Close MA (Forces Non-Repainting)', minval=0, step=1)
tradeType = input.string('BOTH', title='What trades should be taken : ', options=['LONG', 'SHORT', 'BOTH', 'NONE'])

// === ADVANCED ALGORITHM SETTINGS ===
// Momentum settings
rsiPeriod = input.int(14, title="RSI Period", minval=10, maxval=30, group="Momentum")
rsiOverbought = input.int(70, title="RSI Overbought", minval=65, maxval=80, group="Momentum")
rsiOversold = input.int(30, title="RSI Oversold", minval=20, maxval=35, group="Momentum")

// Volume settings
volumePeriod = input.int(20, title="Volume SMA Period", minval=10, maxval=50, group="Volume")
volumeMultiplier = input.float(1.5, title="Volume Multiplier", minval=1.0, maxval=3.0, step=0.1, group="Volume")

// Market structure settings
swingLength = input.int(10, title="Swing High/Low Length", minval=5, maxval=20, group="Market Structure")
atrPeriod = input.int(14, title="ATR Period", minval=10, maxval=30, group="Market Structure")
atrMultiplier = input.float(1.5, title="ATR Multiplier", minval=1.0, maxval=3.0, step=0.1, group="Market Structure")

// Multi-timeframe settings
htfPeriod = input.string("D", title="Higher Timeframe", options=["1", "3", "5", "15", "30", "60", "D", "W"], group="Multi-Timeframe")
ltfPeriod = input.string("5", title="Lower Timeframe", options=["1", "3", "5", "15", "30", "60", "D", "W"], group="Multi-Timeframe")

// Exit management
enableTrailingStop = input.bool(true, title="Enable Trailing Stop", group="Exit Management")
trailingStopPercent = input.float(1.5, title="Trailing Stop %", minval=0.5, maxval=5.0, step=0.1, group="Exit Management")
enableTakeProfit = input.bool(true, title="Enable Take Profit", group="Exit Management")
takeProfitPercent = input.float(2.5, title="Take Profit %", minval=1.0, maxval=10.0, step=0.1, group="Exit Management")
enableStopLoss = input.bool(true, title="Enable Stop Loss", group="Exit Management")
stopLossPercent = input.float(1.5, title="Stop Loss %", minval=0.5, maxval=5.0, step=0.1, group="Exit Management")

// === /INPUTS ===

// === NON-REPAINTING SECURITY FUNCTION ===
rp_security(_symbol, _res, _src) =>
    request.security(_symbol, _res, _src, barmerge.gaps_off, barmerge.lookahead_off)

// === ADVANCED ALGORITHM FUNCTIONS ===

// Function to calculate dynamic support and resistance
getSupportResistance() =>
    var float resistance = na
    var float support = na
    
    // Calculate swing highs and lows
    swingHigh = ta.pivothigh(high, swingLength, swingLength)
    swingLow = ta.pivotlow(low, swingLength, swingLength)
    
    // Update resistance level
    if not na(swingHigh)
        resistance := swingHigh
    else
        resistance := resistance
    
    // Update support level
    if not na(swingLow)
        support := swingLow
    else
        support := support
    
    [support, resistance]

// Function to calculate momentum divergence
getMomentumDivergence() =>
    // RSI divergence detection
    rsi = ta.rsi(close, rsiPeriod)
    
    // Higher highs in price vs lower highs in RSI (bearish divergence)
    priceHigherHigh = high > high[swingLength]
    rsiLowerHigh = rsi < rsi[swingLength]
    bearishDivergence = priceHigherHigh and rsiLowerHigh and rsi > rsiOverbought
    
    // Lower lows in price vs higher lows in RSI (bullish divergence)
    priceLowerLow = low < low[swingLength]
    rsiHigherLow = rsi > rsi[swingLength]
    bullishDivergence = priceLowerLow and rsiHigherLow and rsi < rsiOversold
    
    [bullishDivergence, bearishDivergence]

// Function to calculate volume confirmation
getVolumeConfirmation() =>
    volumeSma = ta.sma(volume, volumePeriod)
    volumeConfirmation = volume > volumeSma * volumeMultiplier
    volumeConfirmation

// Function to calculate volatility filter
getVolatilityFilter() =>
    atr = ta.atr(atrPeriod)
    atrSma = ta.sma(atr, atrPeriod)
    volatilityFilter = atr > atrSma * atrMultiplier
    volatilityFilter

// Function to get multi-timeframe trend
getMultiTimeframeTrend() =>
    // Higher timeframe trend
    htfClose = rp_security(syminfo.tickerid, htfPeriod, close)
    htfEma = rp_security(syminfo.tickerid, htfPeriod, ta.ema(close, 50))
    htfTrend = htfClose > htfEma
    
    // Lower timeframe momentum
    ltfClose = rp_security(syminfo.tickerid, ltfPeriod, close)
    ltfEma = rp_security(syminfo.tickerid, ltfPeriod, ta.ema(close, 20))
    ltfMomentum = ltfClose > ltfEma
    
    [htfTrend, ltfMomentum]

// Function to calculate advanced entry conditions
getEntryConditions() =>
    // Get all components
    [support, resistance] = getSupportResistance()
    [bullishDivergence, bearishDivergence] = getMomentumDivergence()
    volumeConfirmation = getVolumeConfirmation()
    volatilityFilter = getVolatilityFilter()
    [htfTrend, ltfMomentum] = getMultiTimeframeTrend()
    
    // Calculate ATR for dynamic levels
    atr = ta.atr(atrPeriod)
    
    // Long entry conditions
    longCondition = false
    if not na(support)
        // Price near support with bullish divergence
        nearSupport = close <= support + atr * 0.5
        longCondition := nearSupport and bullishDivergence and volumeConfirmation and volatilityFilter and htfTrend and ltfMomentum
    
    // Short entry conditions
    shortCondition = false
    if not na(resistance)
        // Price near resistance with bearish divergence
        nearResistance = close >= resistance - atr * 0.5
        shortCondition := nearResistance and bearishDivergence and volumeConfirmation and volatilityFilter and not htfTrend and not ltfMomentum
    
    [longCondition, shortCondition]

// Function to calculate exit conditions
getExitConditions() =>
    // Get support and resistance levels
    [support, resistance] = getSupportResistance()
    atr = ta.atr(atrPeriod)
    
    // Exit long conditions
    exitLong = false
    if not na(support)
        // Exit when price breaks below support or RSI becomes overbought
        rsi = ta.rsi(close, rsiPeriod)
        exitLong := close < support - atr * 0.5 or rsi > rsiOverbought
    
    // Exit short conditions
    exitShort = false
    if not na(resistance)
        // Exit when price breaks above resistance or RSI becomes oversold
        rsi = ta.rsi(close, rsiPeriod)
        exitShort := close > resistance + atr * 0.5 or rsi < rsiOversold
    
    [exitLong, exitShort]

// === BASE FUNCTIONS ===
// Returns MA input selection variant, default to SMA if blank or typo.
variant(type, src, len, offSig, offALMA) =>
    v1 = ta.sma(src, len)  // Simple
    v2 = ta.ema(src, len)  // Exponential
    v3 = 2 * v2 - ta.ema(v2, len)  // Double Exponential
    v4 = 3 * (v2 - ta.ema(v2, len)) + ta.ema(ta.ema(v2, len), len)  // Triple Exponential
    v5 = ta.wma(src, len)  // Weighted
    v6 = ta.vwma(src, len)  // Volume Weighted
    v7 = 0.0
    sma_1 = ta.sma(src, len)  // Smoothed
    v7 := na(v7[1]) ? sma_1 : (v7[1] * (len - 1) + src) / len
    v8 = ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), math.round(math.sqrt(len)))  // Hull
    v9 = ta.linreg(src, len, offSig)  // Least Squares
    v10 = ta.alma(src, len, offALMA, offSig)  // Arnaud Legoux
    v11 = ta.sma(v1, len)  // Triangular (extreme smooth)
    // SuperSmoother filter
    // Â© 2013  John F. Ehlers
    a1 = math.exp(-1.414 * 3.14159 / len)
    b1 = 2 * a1 * math.cos(1.414 * 3.14159 / len)
    c2 = b1
    c3 = -a1 * a1
    c1 = 1 - c2 - c3
    v12 = 0.0
    v12 := c1 * (src + nz(src[1])) / 2 + c2 * nz(v12[1]) + c3 * nz(v12[2])
    type == 'EMA' ? v2 : type == 'DEMA' ? v3 : type == 'TEMA' ? v4 : type == 'WMA' ? v5 : type == 'VWMA' ? v6 : type == 'SMMA' ? v7 : type == 'HullMA' ? v8 : type == 'LSMA' ? v9 : type == 'ALMA' ? v10 : type == 'TMA' ? v11 : type == 'SSMA' ? v12 : v1

// === /BASE FUNCTIONS ===

// === SERIES SETUP ===
closeSeries = variant(basisType, close[delayOffset], basisLen, offsetSigma, offsetALMA)
openSeries = variant(basisType, open[delayOffset], basisLen, offsetSigma, offsetALMA)
// === /SERIES ===

// Get Alternate resolution Series if selected - USING NON-REPAINTING FUNCTION
closeSeriesAlt = useRes ? rp_security(syminfo.tickerid, stratRes, closeSeries) : closeSeries
openSeriesAlt = useRes ? rp_security(syminfo.tickerid, stratRes, openSeries) : openSeries

// === ADVANCED SIGNAL GENERATION ===
// Get entry and exit conditions
[longCondition, shortCondition] = getEntryConditions()
[exitLong, exitShort] = getExitConditions()

// Combine with original crossover logic for additional confirmation
basicLong = ta.crossover(closeSeriesAlt, openSeriesAlt)
basicShort = ta.crossunder(closeSeriesAlt, openSeriesAlt)

// Final signals with multiple confirmations
buy = longCondition and basicLong
sell = shortCondition and basicShort

// === SIGNAL PLOTTING ===
plotshape(buy,  title = "Buy",  text = 'BUY',  style = shape.labelup,   location = location.belowbar, color= #00DBFF, textcolor = #FFFFFF, transp = 0, size = size.normal)
plotshape(sell, title = "Sell", text = 'SELL', style = shape.labeldown, location = location.abovebar, color= #E91E63, textcolor = #FFFFFF, transp = 0, size = size.normal)

// Plot exit signals
plotshape(exitLong, title="Exit Long", text='EXIT', style=shape.circle, location=location.abovebar, color=color.orange, textcolor=color.white, size=size.small)
plotshape(exitShort, title="Exit Short", text='EXIT', style=shape.circle, location=location.belowbar, color=color.orange, textcolor=color.white, size=size.small)

// === STRATEGY ===
// stop loss
slPoints = input.int(defval=0, title='Initial Stop Loss Points (zero to disable)', minval=0)
tpPoints = input.int(defval=0, title='Initial Target Profit Points (zero for disable)', minval=0)
// Include bar limiting algorithm
ebar = input.int(defval=4000, title='Number of Bars for Back Testing', minval=0)
dummy = input(false, title='- SET to ZERO for Daily or Longer Timeframes')

//
// Calculate how many bars since last bar
tdays = (timenow - time) / 60000.0  // number of minutes since last bar
tdays := timeframe.ismonthly ? tdays / 1440.0 / 5.0 / 4.3 / timeframe.multiplier : timeframe.isweekly ? tdays / 1440.0 / 5.0 / timeframe.multiplier : timeframe.isdaily ? tdays / 1440.0 / timeframe.multiplier : tdays / timeframe.multiplier  // number of bars since last bar
//
//set up exit parameters
TP = tpPoints > 0 ? tpPoints : na
SL = slPoints > 0 ? slPoints : na

// === /STRATEGY ===

// === ALERT MESSAGES ===
i_alert_txt_entry_long = input.text_area(defval = "", title = "Long Entry Message", group = "Alerts")
i_alert_txt_entry_short = input.text_area(defval = "", title = "Short Entry Message", group = "Alerts")

// === STRATEGY EXECUTION ===
// Entries and Exits with TP/SL
if buy and tradeType != 'SHORT' and tradeType != 'NONE'
    strategy.entry("Long" , strategy.long , alert_message = i_alert_txt_entry_long)

if sell and tradeType != 'LONG' and tradeType != 'NONE'
    strategy.entry("Short" , strategy.short, alert_message = i_alert_txt_entry_short)

// === ADVANCED EXIT MANAGEMENT ===
// Exit long positions
if exitLong and strategy.position_size > 0
    strategy.close("Long", comment="Advanced Exit Signal")

// Exit short positions  
if exitShort and strategy.position_size < 0
    strategy.close("Short", comment="Advanced Exit Signal")

// === VISUAL INDICATORS ===
// Plot support and resistance levels
[support, resistance] = getSupportResistance()
plot(support, title="Dynamic Support", color=color.green, linewidth=2, style=plot.style_line)
plot(resistance, title="Dynamic Resistance", color=color.red, linewidth=2, style=plot.style_line)

// Plot RSI levels
rsi = ta.rsi(close, rsiPeriod)
hline(rsiOverbought, title="RSI Overbought", color=color.red, linestyle=hline.style_dashed)
hline(rsiOversold, title="RSI Oversold", color=color.green, linestyle=hline.style_dashed)

// Plot volume confirmation
volumeSma = ta.sma(volume, volumePeriod)
plot(volumeSma, title="Volume SMA", color=color.gray, linewidth=1, display=display.none)

// === SIGNAL QUALITY INDICATOR ===
// Create a signal quality score (0-100)
signalQuality = 0.0
if buy or sell
    signalQuality := 40.0  // Base score for advanced algorithm
    
    // Add points for each confirmation
    [htfTrend, ltfMomentum] = getMultiTimeframeTrend()
    if htfTrend and ltfMomentum
        signalQuality := signalQuality + 30.0
    
    if getVolumeConfirmation()
        signalQuality := signalQuality + 15.0
    
    if getVolatilityFilter()
        signalQuality := signalQuality + 15.0

// Plot signal quality as background color
bgcolor(buy or sell ? color.new(color.green, 90 - signalQuality) : na, title="Signal Quality")

// === PERFORMANCE METRICS ===
// Calculate win rate
winRate = strategy.wintrades / (strategy.wintrades + strategy.losstrades) * 100
winRate := na(winRate) ? 0 : winRate

// Calculate profit factor
profitFactor = strategy.grossprofit / strategy.grossloss
profitFactor := na(profitFactor) ? 0 : profitFactor

// Display performance metrics on chart
if barstate.islast
    label.new(bar_index, high, "Win Rate: " + str.tostring(math.round(winRate, 2)) + "%\nProfit Factor: " + str.tostring(math.round(profitFactor, 2)), 
              color=winRate > 70 ? color.green : winRate > 60 ? color.orange : color.red,
              textcolor=color.white, style=label.style_label_down, size=size.small)

// === MARKET STRUCTURE ANALYSIS ===
// Show market structure labels
if barstate.islast
    [htfTrend, ltfMomentum] = getMultiTimeframeTrend()
    trendText = htfTrend ? "HTF: BULLISH" : "HTF: BEARISH"
    momentumText = ltfMomentum ? "LTF: BULLISH" : "LTF: BEARISH"
    
    label.new(bar_index - 50, low, trendText + "\n" + momentumText,
              color=htfTrend and ltfMomentum ? color.green : not htfTrend and not ltfMomentum ? color.red : color.orange,
              textcolor=color.white, style=label.style_label_up, size=size.small)

